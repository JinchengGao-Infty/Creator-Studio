# 任务：T2.3 实现模型列表获取与缓存

## 任务目标

实现从 Provider 的 `/models` 端点获取模型列表，并缓存到配置中。

## 背景

- T2.1 已完成：Provider 数据结构在 `src-tauri/src/config.rs`
- T2.2 已完成：API Key 存储在 `src-tauri/src/keyring_store.rs`
- Provider 结构中已有 `models: Vec<String>` 和 `models_updated_at: Option<u64>` 字段

## 你需要做的

### 1. 在 ai-engine 中实现模型列表获取

创建 `packages/ai-engine/src/models.ts`：

```typescript
export interface ModelInfo {
  id: string
  name?: string
  owned_by?: string
}

export interface ModelsResponse {
  data: ModelInfo[]
  object: string
}

export async function fetchModels(
  baseURL: string,
  apiKey: string
): Promise<string[]> {
  const url = `${baseURL}/models`
  
  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
  })
  
  if (!response.ok) {
    throw new Error(`Failed to fetch models: ${response.status} ${response.statusText}`)
  }
  
  const data: ModelsResponse = await response.json()
  return data.data.map(m => m.id)
}
```

更新 `packages/ai-engine/src/index.ts`，导出新模块：
```typescript
export * from './models'
```

### 2. 在 ai-engine CLI 中添加 fetch_models 命令

更新 `packages/ai-engine/src/cli.ts`，支持新的请求类型：

```typescript
// 新增请求类型
// {
//   "type": "fetch_models",
//   "baseURL": "...",
//   "apiKey": "..."
// }

// 返回
// { "type": "models", "models": ["model-1", "model-2", ...] }
// 或
// { "type": "error", "message": "..." }

if (input.type === 'fetch_models') {
  try {
    const models = await fetchModels(input.baseURL, input.apiKey)
    console.log(JSON.stringify({ type: 'models', models }))
  } catch (error) {
    console.log(JSON.stringify({ type: 'error', message: String(error) }))
  }
  process.exit(0)
}
```

### 3. 在 Tauri 中实现模型列表获取命令

更新 `src-tauri/src/ai_bridge.rs`，添加获取模型列表的函数：

```rust
pub fn fetch_models(base_url: &str, api_key: &str) -> Result<Vec<String>, String> {
    // 启动 bun 运行 ai-engine
    let ai_engine_path = get_ai_engine_path()?;
    
    let mut child = Command::new("bun")
        .arg("run")
        .arg(&ai_engine_path)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| format!("Failed to spawn ai-engine: {}", e))?;
    
    let mut stdin = child.stdin.take().ok_or("Failed to get stdin")?;
    let stdout = child.stdout.take().ok_or("Failed to get stdout")?;
    let mut reader = BufReader::new(stdout);
    
    // 发送请求
    let request = json!({
        "type": "fetch_models",
        "baseURL": base_url,
        "apiKey": api_key,
    });
    
    writeln!(stdin, "{}", request.to_string())
        .map_err(|e| format!("Failed to write to stdin: {}", e))?;
    drop(stdin); // 关闭 stdin
    
    // 读取响应
    let mut line = String::new();
    reader.read_line(&mut line)
        .map_err(|e| format!("Failed to read from stdout: {}", e))?;
    
    let response: Value = serde_json::from_str(&line)
        .map_err(|e| format!("Failed to parse response: {}", e))?;
    
    match response["type"].as_str() {
        Some("models") => {
            let models = response["models"]
                .as_array()
                .ok_or("Invalid models format")?
                .iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect();
            Ok(models)
        }
        Some("error") => {
            Err(response["message"].as_str().unwrap_or("Unknown error").to_string())
        }
        _ => Err(format!("Unknown response: {}", line)),
    }
}
```

### 4. 注册 Tauri Command

在 `src-tauri/src/lib.rs` 添加：

```rust
use std::time::{SystemTime, UNIX_EPOCH};

#[tauri::command]
async fn refresh_provider_models(provider_id: String) -> Result<Vec<String>, String> {
    // 获取 Provider 配置
    let config = config::load_config()?;
    let provider = config.providers
        .iter()
        .find(|p| p.id == provider_id)
        .ok_or(format!("Provider {} not found", provider_id))?
        .clone();
    
    // 获取 API Key
    let api_key = keyring_store::get_api_key(&provider_id)?
        .ok_or(format!("API Key not found for provider {}", provider_id))?;
    
    // 获取模型列表
    let models = ai_bridge::fetch_models(&provider.base_url, &api_key)?;
    
    // 更新配置
    let mut config = config::load_config()?;
    if let Some(p) = config.providers.iter_mut().find(|p| p.id == provider_id) {
        p.models = models.clone();
        p.models_updated_at = Some(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs()
        );
    }
    config::save_config(&config)?;
    
    Ok(models)
}

#[tauri::command]
fn get_provider_models(provider_id: String) -> Result<Vec<String>, String> {
    let config = config::load_config()?;
    let provider = config.providers
        .iter()
        .find(|p| p.id == provider_id)
        .ok_or(format!("Provider {} not found", provider_id))?;
    
    Ok(provider.models.clone())
}

// 在 invoke_handler 中注册
.invoke_handler(tauri::generate_handler![
    // ... 现有命令
    refresh_provider_models,
    get_provider_models,
])
```

### 5. 缓存策略

在前端调用时实现缓存策略（可选，也可以在后端实现）：

```typescript
// 缓存有效期：24小时
const CACHE_TTL = 24 * 60 * 60 * 1000

async function getModels(providerId: string): Promise<string[]> {
  const provider = await invoke('get_provider', { providerId })
  
  // 检查缓存是否有效
  const now = Date.now()
  const updatedAt = provider.models_updated_at ? provider.models_updated_at * 1000 : 0
  
  if (provider.models.length > 0 && (now - updatedAt) < CACHE_TTL) {
    // 使用缓存
    return provider.models
  }
  
  // 刷新模型列表
  try {
    return await invoke('refresh_provider_models', { providerId })
  } catch (error) {
    // 刷新失败，返回缓存（如果有）
    if (provider.models.length > 0) {
      console.warn('Failed to refresh models, using cache:', error)
      return provider.models
    }
    throw error
  }
}
```

### 6. 测试

使用测试 API 验证：

```
Base URL: http://127.0.0.1:3002/geminicli/v1
API Key: sk-XnbHbzBOmPYGHgL_4Mg8zRcoBIb2gVpJiuO0eSifyyCUV2Twz2c4SljcNCo
```

1. 先添加一个 Provider
2. 调用 `refresh_provider_models` 获取模型列表
3. 验证模型列表被缓存到配置中
4. 调用 `get_provider_models` 验证能读取缓存

## 输出

- `packages/ai-engine/src/models.ts` - 模型列表获取
- `packages/ai-engine/src/cli.ts` - 更新支持 fetch_models
- `src-tauri/src/ai_bridge.rs` - 更新支持 fetch_models
- `src-tauri/src/lib.rs` - 注册新命令
- `cargo check` 通过
- `bun test` 通过（如果有测试）

## 完成标记

完成后在输出末尾标记：`[TASK_COMPLETE]`

如果遇到问题无法解决，标记：`[TASK_FAILED: 原因]`
